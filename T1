#include <stdio.h>
#include <stdlib.h>
#include <conio.h>

/*registro que reprensentará cada elemento da pilha*/
struct Elemento_pilha{
	int num;
	struct Elemento_pilha *prox;
};
typedef struct Elemento_pilha Elemento_pilha;

/*registro do tipo Pilha contento um ponteiro "topo" do tipo Elemento para controlar a pilha*/
struct Pilha{
    struct Elemento_pilha *topo;/*aponta para o elemento que esta Elemento topo da pilha*/
};
typedef struct Pilha Pilha;

 /*ponteiro auxiliar*/
 Elemento_pilha *aux ;


 /*registro que reprensentará cada elemento da fila*/
struct Elemento_fila{
	int num;
	struct Elemento_fila *prox;
};
typedef struct Elemento_fila Elemento_fila;

/*registro do tipo Lista contento dois ponteiros do tipo nó para controlar a fila*/
struct Fila{
    struct Elemento_fila *inicio; /*aponta para o elemento do início da fila*/
    struct Elemento_fila *fim; /*aponta para o elemento do fim da fila*/
};
typedef struct Fila Fila;

 /*ponteiro auxiliar*/
 Elemento_fila *aux2 ;


Pilha* cria_pilha(){
	/*alocação do ponteiro pi para controlar a pilha*/
    Pilha* pi = (Pilha*) malloc(sizeof(Pilha));
    if(pi != NULL){
        pi->topo= NULL;  /*a pilha inicia-se vazia, portanto seu topo é igual a NULL*/
    }
    return pi;
}

Fila* cria_fila(){
	/*alocação do ponteiro li para controlar a lista*/
    Fila* fi = (Fila*) malloc(sizeof(Fila));
    if(fi != NULL){
		/*a fila inicia-se vazia, portanto inicio e fim são iguais a NULL*/
        fi->fim = NULL;
        fi->inicio = NULL;
    }
    return fi;
}

/*todo elemento será inserido no topo da pilha*/
void insere_elemento_pilha(Pilha *pi){
	/*a cada inserção alocamos dinamicamente um espaço para um novo elemento*/
	Elemento_pilha *novo =(Elemento_pilha*) malloc(sizeof(Elemento_pilha));
	printf("\nDigite o numero a ser inserido na pilha: ");
	scanf("%d",&novo->num);
	/*como o número inserido será o novo topo, ele apontará para o topo atual que será o segundo elemento da pilha*/
	novo->prox = pi->topo;
	/*topo aponta para o endereço de novo*/
	pi->topo = novo;
	printf("\nNumero inserido na pilha!\n");
	getch();
}

void insere_elemento_fila(Fila *fi){
	/*a cada inserção alocamos dinamicamente um espaço para um novo elemento*/
	Elemento_fila *novo =(Elemento_fila*) malloc(sizeof(Elemento_fila));
	printf("\nDigite o numero a ser inserido na fila: ");
	scanf("%d",&novo->num);
	novo->prox = NULL;
	/*caso a fila esteja vazia, o elemento inserido será o primeiro e o último */
	if(fi->inicio == NULL){
		fi->inicio = novo;
		fi->fim = novo;
	/*caso a pilha ja contenha algum elemento, o novo elemento será sempre inserido no fim da fila*/
	}else{
		fi->fim->prox = novo;
		fi->fim = novo;
	}
	printf("\nNumero inserido na fila!\n");
	getch();
}

/* função verifica os números que estão nas duas estruturas
   cada elemento da pilha é comparado os todos elementos da fila verificando a igualdade*/
void consulta_iguais(Pilha *pi, Fila *fi){
    int achou;
    aux = pi->topo;
    /*looping da pilha*/
    do{
        achou = 0;
        aux2 = fi->inicio;
         /*looping da fila*/
        do{
            if(aux2->num == aux->num)
                achou ++;
            aux2 = aux2->prox;
        } while(aux2 != NULL);

        if(achou > 0)
            printf(" %d", aux->num);
        aux = aux->prox;
    } while(aux != NULL);
	getch();
}

/* função verifica os números que estão somente na pilha
   cada elemento da pilha é comparado os todos elementos da fila*/
void consulta_pilha(Pilha *pi, Fila *fi){
    int achou;
    aux = pi->topo;
     /*looping da pilha*/
    do{
        achou = 0;
        aux2 = fi->inicio;
         /*looping da fila*/
        do{
            if(aux2->num == aux->num)
                achou ++;
            aux2 = aux2->prox;
        } while(aux2 != NULL);
        if(achou == 0)
            printf(" %d", aux->num);
        aux = aux->prox;
    } while(aux != NULL);
	getch();
}

/* função verifica os números que estão somente na fila
   cada elemento da fila é comparado os todos elementos da pilha*/
void consulta_fila(Pilha *pi, Fila *fi){
    int achou;
    aux2 = fi->inicio;
    /*looping da fila*/
    do{
        achou = 0;
        aux = pi->topo;
        /*looping da pilha*/
        do{
            if(aux2->num == aux->num)
                achou ++;
            aux = aux->prox;
        } while(aux != NULL);
        if(achou == 0)
            printf(" %d", aux2->num);
        aux2 = aux2->prox;
    } while(aux2 != NULL);
	getch();
}

/*o elemento a ser removido será sempre o topo(último elemento inserido)*/
void remove_elemento_pilha(Pilha *pi){
	 if(pi->topo ==  NULL){
		printf("\nPilha Vazia!!");
	} else{
		aux = pi->topo;
		printf("%d removido!", pi->topo->num);
		pi->topo = pi->topo->prox;
		free(aux);
	}
	getch();
}

/*o elemento a ser removido será sempre o primeiro elemento inserido(inicio)*/
void remove_elemento_fila(Fila *fi){
	if(fi->inicio == NULL){
		printf("\nFila Vazia!!");
	} else{
		aux2 = fi->inicio;
		printf("%d removido!", fi->inicio->num);
		fi->inicio = fi->inicio->prox;
		free(aux2);
	}
	getch();
}

/*a pilha será esvaziada e o espaço ocupado por ela será desalocado*/
void esvazia_pilha(Pilha *pi){
	if(pi->topo == NULL){
		printf("\nPilha Vazia!!");
	}else{
		aux = pi->topo;
		do{
			pi->topo = pi->topo->prox;
			free(aux);
			aux = pi->topo;
		}while(aux != NULL);
		printf("\nPilha Esvaziada!!");
	}
	getch();
}
/*a fila será esvaziada e o espaço ocupado por ela será desalocado*/
void esvazia_fila(Fila *fi){
	if(fi->inicio == NULL){
		printf("\nFila Vazia!!");
	}else{
		aux2 = fi->inicio;
		do{
			fi->inicio = fi->inicio->prox;
			free(aux2);
			aux2 = fi->inicio;
		}while(aux2 != NULL);
		printf("\nFila Esvaziada!!");
	}
	getch();
}

/*removi o original, alteração realizada a partir deste ponto*/

int main(){
    int N, K, I, contP, contF; 
	int isFila = 0; // fila
    int isPilha = 0; // pilha
    int notDefinido = 0;
    int isNotPilha = 0;
    int isNotFila = 0;
	int Topo;  
	char C;

	scanf("%d", &N);
	
	contP = 0;


	for (int i = 0; i < N; i++) { // indica valores entre 1 à 100
        Pilha *pi = cria_pilha();
		Fila *fi = cria_fila();

		scanf("%d", &K);

		for (int j = 0; j < K; j++) { // indica os valores do caso de teste entre 2 a 100
			scanf(" %c %d", &C, &I);

            if (C == 'i') {            	         	
            	insere_elemento_pilha(pi);
                insere_elemento_fila(fi);
                system("CLS");
                
            } else if (C == 'r') {
               	remove_elemento_pilha(pi);
               	Topo = pi->topo;
            	remove_elemento_fila(fi);
            	system("CLS");
            	
                
                if (pi.topo == I && isNotPilha != 1) { // pilha
                    isPilha++;
                } 
                
                if (filaRemovido.chave == I && isNotFila != 1) { // filha
                    isFila++;
                }

                if (filaRemovido.chave == I && pilhaRemovido.chave == I) { // impossivel
                    notDefinido++;
                }

                if (pilhaRemovido.chave != I) { // invalida pilha
                    isNotPilha = 1;
                }

                if (filaRemovido.chave != I) { // invalida fila
                    isNotFila = 1;
                }
            }
		}
        
        // printf("isStack %d isQueue %d itemNotFoundQueue %d itemNotFoundStack %d isNotDefinedMoreOneTime %d\n", isStack, isQueue, itemNotFoundQueue, itemNotFoundStack, isNotDefinedMoreOneTime);
        if (isPilha > isFila) {
            if (isNotPilha == 1) {
                printf("impossivel\n");   
            } else {
                printf("pilha\n");
            }
        } else if (isFila > isPilha) {
            if (isNotFila == 1) {
                printf("impossivel\n");   
            } else {
                printf("fila\n");
            }
        } else if (isFila == isPilha && (isNotFila > 0 || isNotPilha > 0)) {
            printf("impossivel\n"); 
        } else {
            printf("indefinido\n");
        }

        isFila = 0;
        isPilha = 0;
        isNotPilha = 0;
        isNotFila = 0;
	}

    return 0;
}
